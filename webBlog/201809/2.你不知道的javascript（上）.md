
##### LHS && RHS 查询
- "L"和"R"是一个赋值操作的左侧和右侧;
- 当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。
- RHS查询与简单地查找某个变量值别无二致，而LHS查询则是试图找到容器本身。
- 生动一点的解释："赋值操作的目标是谁（LHS）" "谁是赋值操作的源头（RHS）"
- 

### 闭包

```
// 在wait函数执行1000s后，它的内部作用域并不会消失，timer函数依然保有wait()作用域的闭包
function wait(msg) {
    seTtimeout( function timer(){
        console.log(msg)
    },1000)
}
wait(msg)
```

##### 重返块作用域
每次迭代都需要一个块作用域。

let声明，可以用来劫持块作用域，并且在这个块作用域声明一个变量，本质上这是将一个块转换成一个可以被关闭的作用域。
```js
for(var i =1; i<=5; i++){
    let j = i;//是的，闭包的快作用域！
    setTimeout(function timer() {
        console.log(j);
    }, j*1000)
}
```
这个行为指出变量在循环的过程中不止被声明一次，每次迭代都会声明。随后的每次迭代都会使用上一个迭代结束时的值来初始化这个变量。

##### 小结
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，此时就产生了闭包。
