
#### this到底是什么

this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this在绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

当一个函数被调用时，会创建一个活动记录（有时也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。

**思考：如何寻找函数的调用位置，从来判断函数在执行过程中会如何绑定this**

首先要明白this既不指向函数自身也不指向函数的词法作用域，this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用（函数的调用方法）。

#### 1.调用位置
寻找“函数被调用的位置”，最重要的要分析调用栈（为了到达当前执行位置所调用的所有函数）。
```
// 看看到底什么是调用栈和调用位置
function baz() {
    // 当前调用栈：baz
    // 因此，当前调用位置是全局作用域
    console.log('baz')
    bar()// <-- bar的调用位置
}
function bar() {
    // 当前调用的栈是 baz -> bar
    // 因此，当前调用位置在baz中
    console.log("bar")
    foo() // <-- foo的调用位置
}
function foo(){
    //当前调用栈是baz—> bar -> foo
    //因此，当前调用位置在bar中
    console.log('foo')
}
baz() // <--baz的调用位置
```
> 调用栈可以想象成一个函数调用链

#### 2.绑定规则
##### 2.1默认绑定
最常用的函数调用类型：独立函数调用。
```
function foo() {
    console.log(a)
}
var a = 2;
foo() //2
```

##### 2.2隐式绑定
调用位置是否有上下文对象，或者说是是否被某个对象拥有或者包含
```
function foo() {
    console.log(this.a)
}
var obj = {
    a: 2,
    foo: foo
}
obj.foo() // 2
// 调用位置会使用obj上下文来引用函数
```
当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。

对象属性引用链中只有最顶层或者说最后一层会影响调用位置。
```
function foo() {
    console.log(this.a)
}
var obj2 = {
    a:42,
    foo:foo
}
var obj1 = {
    a:2,
    foo:foo
}
obj1.obj2.foo() // 42
```
**隐式丢失**
一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式

##### 2.3显示绑定
如果不想在对象内部包含函数引用，而想在某个对象上强制调用函数，怎么做？
可以使用函数的call(...)和apply(...)。

这俩方法如何工作的呢？它们的第一个参数是一个对象，会把这个对象绑定到this，接着在调用函数时指定这个this。直接指定this的绑定对象，称之为显式绑定。
```
function foo() {
    console.log(this.a)
}
var obj = {
    a:2
}
foo.call(obj) //2
```

##### 2.4new绑定
包括内置对象函数在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。

使用new调用函数，或者说发生构造函数调用时，会自动执行下面操作：
- 创建（构造）一个全新的对象
- 这个新对象会被执行[[原型]]链接
- 这个新对象会绑定到函数调用的this
- 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

#### 优先级
默认绑定的优先级是最低
显示绑定高于隐式绑定
new绑定比隐式绑定优先级搞
硬绑定（显式绑定）比new绑定更高

为什么要在new中使用硬绑定函数呢？直接使用普通函数不是更简单吗？

之所以在new中使用硬绑定函数，主要目的预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。bind(...)的功能之一就是可以把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层（这种技术成为“部分应用”，是“柯里化”一种）
```
function foo(p1, p2){
    this.val = p1 + p2   
}
// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么
// 反正使用new时this会被修改
var bar = foo.bind(null, "p1")
var baz = new bar("p2")
baz.val // p1p2
```

**判断this**

根据优先级来判断函数在某个调用位置应用的是哪条规则
```js
// 1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。
var bar = new foo()
// 2.函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是指定对象
var bar = foo.call(obj2)
// 3.函数都否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象
var bar = obj1.foo()
// 4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined ，否则绑定到全局对象
var bar = foo()
```

#### this词法
箭头函数是根据外层（函数或者全局）作用域来决定this。

箭头函数可以像bind(...)一样确保函数的this被绑定到指定对象
