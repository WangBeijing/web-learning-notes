## 交易
####简介
比特币交易是比特币系统中最重要的部分。根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币总账薄（比特币区块链）。比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复式记账总账薄，每个比特币交易都是在比特币区块链上的一个公开交易。

### 交易细节
![Images](https://github.com/WangBeijing/webBlog/blob/master/BlockChain/Images/WX20181012-110429.png?raw=true)

#### 交易-幕后细节
事实上，在各种比特币应用程序用户界面中看到大多数高级结构实际上并不存在于比特币系统中。

#### 交易的输入输出
比特币交易中的基础构建单元是交易输出。 交易输出是比特币不可分割的基本组合，记录在区块上，并被整个网络 识别为有效。 比特币完整节点跟踪所有可找到的和可使用的输出，称为“未花费的交易输出”(unspent transaction outputs)，即UTXO。 所有UTXO的集合被称为UTXO集，目前有数百万个UTXO。 当新的UTXO被创建，UTXO集就会变大，当UTXO被消耗时，UTXO集会随着缩小。每一个交易都代表UTXO集的变化(状态转换)。

当我们说用户的钱包已经“收到”比特币时，我们的意思是，钱包已经检测到了可用的UTXO。通过钱包所控制的密 钥，我们可以把这些UTXO花出去。 因此，用户的比特币“余额”是指用户钱包中可用的UTXO总和，而他们可能分散 在数百个交易和区块中。 “一个用户的比特币余额”，这个概念是比特币钱包应用创建的派生之物。比特币钱包通过 扫描区块链并聚集所有属于该用户的UTXO来计算该用户的余额 。大多数钱包维护一个数据库或使用数据库服务来 存储所有UTXO的快速参考集，这些UTXO由用户所有的密钥来控制花费行为。

一个UTXO可以是1“聪”(satoshi)的任意倍数(整数倍)。就像美元可以被分割成表示两位小数的“分”一样，比特 币可以被分割成八位小数的“聪”。尽管UTXO可以是任意值，但一旦被创造出来，即不可分割。这是UTXO值得被强 调的一个重要特性:UTXO是面值为“聪”的离散(不连续)且不可分割的价值单元，一个UTXO只能在一次交易中作 为一个整体被消耗。

如果一个 UTXO比一笔交易所需量大，它仍会被当作一个整体而消耗掉，但同时会在交易中生成零头。

由于UTXO(或交易输 出)的不可分割特性，大部分比特币交易都会产生找零。

一笔比特币交易可以是任意金额，但必须从用户可用的UTXO中创建出来。用户不能再把UTXO进一步细 分，就像不能把一元纸币撕开而继续当货币使用一样。用户的钱包应用通常会从用户可用的UTXO中选取多个来拼 凑出一个大于或等于一笔交易所需的比特币量。

一笔交易会消耗先前的已被记录(存在)的UTXO，并创建新的UTXO以备未来的交易消耗。通过这种方式，一定数 量的比特币价值在不同所有者之间转移，并在交易链中消耗和创建UTXO。一笔比特币交易通过使用所有者的签名 来解锁UTXO，并通过使用新的所有者的比特币地址来锁定并创建UTXO。

从交易的输出与输入链角度来看，有一个例外，即存在一种被称为“币基交易”(Coinbase Transaction)的特殊交 易，它是每个区块中的第一笔交易，这种交易存在的原因是作为对挖矿的奖励，创造出全新的可花费比特币用来支 付给“赢家”矿工。这也就是为什么比特币可以在挖矿过程中被创造出来，我们将在“挖矿”这一章进行详述。

> 输入和输出，哪一个是先产生的呢?先有鸡还是先有蛋呢?严格来讲，先产生输出，因为可以创造新 比特币的 “币基交易”没有输入，但它可以无中生有地产生输出。

#### 交易输出

每一笔比特币交易都会创造输出，并被比特币账簿记录下来。除特例之外(见“数据输出操作 符”(OP_RETURN))，几乎所有的输出都能创造一定数量的可用于支付的比特币，也就是UTXO。这些UTXO被整 个网络识别，所有者可在未来的交易中使用它们。

UTXO在UTXO集(UTXOset)中被每一个全节点比特币客户端追踪。 新的交易从UTXO集中消耗(花费)一个或多个输出。

交易输出包含两部分:
- 一定量的比特币，面值为“聪”(satoshis) ，是最小的比特币单位; 
- 确定花费输出所需条件的加密难题(cryptographic puzzle)

这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。

在 JSON 编码中，输出位于名为 vout 的数组(列表)中:
```
"vout": [
    {
        'value': 0.015000000,
        'scriptPubkey':'OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"'
    },
    {
        'value': 0.084500000,
        'scriptPubkey':'OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"'
    }
]
```
如上述所见，交易包含两个输出。每个输出都由一个值和一个加密难题来定义。

在脚本构造（Lock + Unlock）中讨论锁定和解锁UTXO的主题。在ScriptPubkey中用于编辑脚本的脚本语言在Transaction Script(交易脚本)和Script Language（脚本语言）中讨论

##### 交易序列化-输出
当交易通过网络传输或在应用程序之间交换时，它们被序列化。 序列化是将内部的数据结构表示转换为可以一次发 送一个字节的格式(也称为字节流)的过程。 序列化最常用于编码通过网络传输或用于文件中存储的数据结构。

大多数比特币函数库和架构不会在内部将交易存储为字节流，因为每次需要访问单个字段时，都需要复杂的解析。为了方便和可读性，比特币函数库将交易内部存储在数据结构(通常是面向对象的结构)中。

从交易的字节流表示转换为函数库的内部数据结构表示的过程称为反序列化或交易解析。转换回字节流以通过网络 传输、哈希化(hashing)或存储在磁盘上的过程称为序列化。大多数比特币函数库具有用于交易序列化和反序列 化的内置函数。

#### 交易输入
交易输入将UTXO(通过引用)标记为将被消费，并通过解锁脚本提供所有权证明。

要构建一个交易，一个钱包从它控制的UTXO中选择足够的价值来执行被请求的付款。 有时一个UTXO就足够，其 他时候不止一个。 对于将用于进行此付款的每个UTXO，钱包将创建一个指向UTXO的输入，并使用解锁脚本解锁 它。

详细地看一下输入的组件，第一部分是一个指向UTXO的指针，通过指向UTXO被记录在区块链中所 在的交易的哈希值和序列号来实现。 第二部分是解锁脚本，钱包构建它用以满足设定在UTXO中的支出条件。 大多 数情况下，解锁脚本是一个证明比特币所有权的数字签名和公钥，但是并不是所有的解锁脚本都包含签名。第三部 分是序列号，稍后再讨论

##### 交易序列号-交易输入
当交易被序列号在网络上传输时，它们的输入被编码成字节流。

#### 交易费
大多数交易包含交易费(矿工费)，这是为了确保网络安全而给比特币矿工的一种补偿。费用本身也作为一个安全机制，使经济上不利于攻击者通过交易来淹没网络。

交易费如何被包含在一个典型的交易中。大多数钱包自动计算并计入交易费。但是， 如果你以编程 方式构造交易，或者使用命令行界面，你必须手动计算并计入这些费用。

交易费作为矿工打包(挖矿)一笔交易到下一个区块中的一种激励;同时作为一种抑制因素，通过对每一笔交易收 取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中。

交易费是基于交易的千字节规模来计算的，而不是比特币交易的价值。总的来说，交易费是根据比特币网络中的市场力量确定的。矿工会依据许多不同的标准对交易进行优先级排序，包括费用，他们甚至可能在某些特定情况下免费处理交易。但大多数情况下，交易费影响处理优先级，这意味着有足够费用的交易会更可能被打包进下一个挖出的区块中;反之交易费不足或者没有交易费的交易可能会被推迟，基于尽力而为的原则在几个区块之后被处理，甚至可能根本不被处理。交易费不是强制的，而且没有交易费的交易最终也可能会被处理，但是，交易费将提高处理优先级。

任何创建交易的比特币服务，包括钱包，交易所，零售应用等，都必须实现动态收费。动态费用可以通过第三方费用估算服务或内置的费用估算算法来实现。如果您不确定，那就从第三方服开始，如果您希望去除第三方依赖，您应当有设计和部署自己算法的经验。

费用估算算法根据网络能力和“竞争”交易提供的费用计算适当的费用。这些算法的范围从十分简单的(最后一个块 中的平均值或中位数)到非常复杂的(统计分析)均有覆盖。他们估计必要的费用(以字节为单位)，这将使得交 易具有很高的可能性被选择并打包进一定数量的块内。大多数服务为用户提供高、中、低优先费用的选择。高优先 级意味着用户支付更高的交易费，但交易可能就会被打包进下一个块中。中低优先级意味着用户支付较低的交易 费，但交易可能需要更长时间才能确认。

#### 把交易费加到交易中

交易的数据结构没有交易费的字段。相替代地，交易费是指输入和输出之间的差值。从所有输入中扣掉所有输出之后的多余的量被矿工作为矿工费收集走：

> 交易费即输入总和减输出总和的余量：交易费 = 求和（所有输入）-求和（所有输出）

正确理解交易比较困难，但又尤为重要。因为如果你要构建你自己的交易，你必须确保你没有因疏忽在交易中添加 一笔大量交易费而大大减少了输入的可花费额。这意味着你必须计算所有的输入，如有必要则加上找零， 不然的 话，结果就是你给了矿工一笔相当可观的劳务费!

### 比特币交易脚本和脚本语言
比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。放置在UTXO上的 锁定脚本和解锁脚本都以此脚本语言编写。 当一笔比特币交易被验证时，每一个输入值中的解锁脚本与其对应的锁 定脚本同时 (互不干扰地)执行，以确定这笔交易是否满足支付条件。

如今大多数比特币网络处理的交易基于一种称为‘P2PKH’（Pay-toPublic- Key-Hash）脚本。

展示比特币交易脚本语言的各个组件：同时也会展示如何使用它去表达简单的使用条件以及如何通过解锁脚本去满足这些花费条件。

#### 图灵非完备性
比特币脚本语言包含许多操作码，但都故意限定为一种重要的模式——除了有条件的流控制以外，没有循环或复杂 流控制能力。

#### 去中心化验证
比特币交易脚本语言是没有中心化主体的，没有任何中心主体能凌驾于脚本之上，也没有中心主体会在脚本被执行
后对其进行保存。

#### 脚本构建（锁定与解锁）
比特币的交易验证引擎依赖于两类脚本来验证比特币交易:锁定脚本和解锁脚本。

锁定脚本是一个放置在输出上面的花费条件:它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含 有一个公钥或比特币地址(公钥哈希值)，在历史上它曾被称为脚本公钥(scriptPubKey)。由于认识到这种脚本 技术存在着更为广泛的可能性，将它称为“锁定脚本”(locking script)。

解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，它将允许输出被消费。解锁脚本是 每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包(通过用户的私钥)生成的数字签名。由 于解锁脚本常常包含一个数字签名，因此它曾被称作ScriptSig。在大多数比特币应用的源代码中，ScriptSig便是我 们所说的解锁脚本。

每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。每个输入都包含一个解锁脚本，并引用了 之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次 执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效(请参阅单独执行解锁和锁定脚本部分)。 所有输入都是独立验证的，作为交易总体验证的一部分。

请注意，UTXO被永久地记录在区块链中，因此是不变的，并且不受在新交易中引用失败的尝试的影响。 只有正确 满足输出条件的有效交易才能将输出视为“开销来源”，继而该输出将被从未花费的交易输出集(UTXO set)中删 除。

下面是最常见的比特币交易(P2PKH:对公钥哈希的付款)的解锁和锁定脚本的示例，显示了在脚本验证之前 从解锁和锁定脚本的并置产生的组合脚本:
![Images](https://github.com/WangBeijing/webBlog/blob/master/BlockChain/Images/WX20181012-141623.png?raw=true)

#### 脚本执行堆栈
比特币的脚本语言被称为基于堆栈的语言，因为它使用一种被称为堆栈的数据结构。堆栈是一个非常简单的数据结 构，可以被视为一叠卡片。栈允许两个操作:push和pop(推送和弹出)。 Push(推送)在堆栈顶部添加一个项 目。 Pop(弹出)从堆栈中删除最顶端的项。栈上的操作只能作用于栈最顶端项目。堆栈数据结构也被称为“后进 先出”( Last-In-First-Out)或 “LIFO” 队列。

脚本语言通过从左到右处理每个项目来执行脚本。数字(数据常量)被推到堆栈上。操作码(Operators)从堆栈 中推送或弹出一个或多个参数，对其进行操作，并可能将结果推送到堆栈上。例如，操作码 OP_ADD 将从堆栈中 弹出两个项目，添加它们，并将结果的总和推送到堆栈上。

条件操作码(Conditional operators)对一个条件进行评估，产生一个 TRUE 或 FALSE 的布尔结果(boolean result)。例如， OP_EQUAL 从堆栈中弹出两个项目，如果它们相等，则推送为 TRUE(由数字1表示)，否则推 送为 FALSE(由数字0表示)。比特币交易脚本通常包含条件操作码，以便它们可以产生用来表示有效交易的 TRUE 结果。

#### 一个简单的脚本

尽管绝大多数解锁脚本都指向一个公钥哈希值(本质上就是比特币地址)，因此如果想要使用资金则需验证所有 权，但脚本本身并不需要如此复杂。任何解锁和锁定脚本的组合如果结果为真(TRUE)，则为有效。前面被我们 用于说明脚本语言的简单算术操作码同样也是一个有效的锁定脚本，该脚本能用于锁定交易输出。

#### 解锁和锁定脚本的单独执行
在最初版本的比特币客户端中，解锁和锁定脚本是以连锁的形式存在，并被依次执行的。

首先，使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错(例如:没有“悬挂”操作码)，则复制 主堆栈(而不是备用堆栈)，并执行锁定脚本。如果从解锁脚本中复制而来的堆栈数据执行锁定脚本的结果 为“TRUE"，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因此，该输入是一个能使用该UTXO的有效授 权。如果在合并脚本后的结果不是”TRUE“以外的任何结果，输入都是无效的，因为它不能满足UTXO中所设置的使 用该笔资金的条件。

### P2PKH(Pay-to-Public-Key-Hash)
比特币网络处理的大多数交易花费的都是由“付款至公钥哈希”(或P2PKH)脚本锁定的输出，这些输出都含有一个 锁定脚本，将输入锁定为一个公钥哈希值，即我们常说的比特币地址。由P2PKH脚本锁定的输出可以通过提供一个 公钥和由相应私钥创建的数字签名来解锁(使用)。

只有当解锁脚本与锁定脚本的设定条件相匹配时，执行组合验证脚本时才会显示结果为真(TRUE)。换句话说， 只有当解锁脚本得到了咖啡馆的有效签名，交易执行结果才会被通过(结果为真)，该有效签名是从与公钥哈希相 匹配的咖啡馆的私钥中所获取的。

### 数字签名（ECDSA）
将研究数字签名的工作原理，以及如何在不揭示私钥的情况下提供私钥的所有权证明。

比特币中使用的数字签名算法是椭圆曲线数字签名算法(Elliptic Curve Digital Signature Algorithm)或ECDSA。 ECDSA是用于基于椭圆曲线私钥/公钥对的数字签名的算法，如椭圆曲线章节[elliptic_curve]所述。ECDSA用于脚 本函数OP_CHECKSIG，OP_CHECKSIGVERIFY，OP_CHECKMULTISIG和OP_CHECKMULTISIGVERIFY。每当你锁 定脚本中看到这些时，解锁脚本都必须包含一个ECDSA签名。

数字签名在比特币中有三种用途(请参阅下面的侧栏)。
- 第一，签名证明私钥的所有者，即资金所有者，已经授权支出这些资金。
- 第二，授权证明是不可否认的(不可否认性)。
- 第三，签名证明交易(或交易的具体部分)在签字之后没有也不能被任何人修改。

> 注意:每个交易输入和它可能包含的任何签名完全独立于任何其他输入或签名。 多方可以协作构建交易，并 各自仅签一个输入。

#### 数字签名如何工作
数字签名是一种由两部分组成的数学方案:第一部分是使用私钥(签名密钥)从消息(交易)创建签名的算法; 第 二部分是允许任何人验证签名的算法，给定消息和公钥。

##### 创建数字签名
在比特币的ECDSA算法的实现中，被签名的“消息”是交易，或更确切地说是交易中特定数据子集的哈希值(参见签名哈希类型(SIGHASH))。签名密钥是用户的私钥，结果是签名:
```
((Sig = F{sig}(F{hash}(m), dA)))
```

- dA 是签名私钥
- m 是交易(或其部分) 
- Fhash 是散列函数
- Fsig 是签名算法
- Sig 是结果签名
ECDSA数学运算的更多细节可以在ECDSA Math章节中找到。 

函数F~sig~ 产生由两个值组成的签名Sig，通常称为R和S:
```
Sig = (R, S)
```
现在已经计算了两个值R和S，它们就序列化为字节流，使用一种称为“分辨编码规则”(Distinguished Encoding Rules)或 DER的国际标准编码方案。
##### 签名序列号（DER）
 在交易输入中有一个解锁脚本，其中包含Alice的钱包中的以下DER编码签名:
```
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9
  f6addac960298cad530a863ea8f53982c09db8f6e381301
```
该签名是Alice的钱包生成的R和S值的序列化字节流，证明她拥有授权花费该输出的私钥。 序列化格式包含以下9个 元素:

- 0x30表示DER序列的开始
- 0x45 - 序列的长度(69字节)
- 0x02 - 一个整数值
- 0x21 - 整数的长度(33字节) 
- R-00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb 0x02 - 接下来是一个整数
- 0x20 - 整数的长度(32字节) 
- S-4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09d- b8f6e3813 后缀(0x01)指示使用的哈希的类型(SIGHASH_ALL)

看看您是否可以使用此列表解码 Alice 的序列化(DER编码)签名。 重要的数字是R和S; 数据的其余部分是DER编 码方案的一部分。

#### 验证签名
要验证签名，必须有签名(R和S)、序列化交易和公钥(对应于用于创建签名的私钥)。本质上，签名的验证意味着“只有生成此公钥的私钥的所有者，才能在此交易上产生此签名。” 

签名验证算法采用消息(交易或其部分的哈希值)、签名者的公钥和签名(R和S值)，如果签名对该消息和公钥有效，则返回TRUE值。

##### 签名哈希类型（SIGHASH）
数字签名被应用于消息，在比特币中，就是交易本身。签名意味着签字人对特定交易数据的承诺( commitment)。在最简单的形式中，签名适用于整个交易，从而承诺(commit)所有输入，输出和其他交易字 段。但是，在一个交易中一个签名可以只承诺(commit)一个数据子集，这对于我们将在本节中看到的许多场景 是有用的。

...

#### ECDSA数学
签名由产生由两个值R和S组成的签名的数学函数F~sig~ 创建。

签名算法首先生成一个 ephemeral(临时)私公钥对。 在涉及签名私钥和交易哈希的变换之后，该临时密钥对用于 计算R和S值。

#### 随机性在签名中的重要性
签名生成算法使用随机密钥k作为临时私有-公钥对的基础。 k 的值不重要，只 要它是随机的。如果使用相同的值 k 在不同的消息(交易)上产生两个签名，那么签名私钥可以由任何人计算。在 签名算法中重用相同的 k 值会导致私钥的暴露
